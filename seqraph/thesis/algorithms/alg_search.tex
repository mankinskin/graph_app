
\section{Search}

The search algorithm finds the location of a given string (calld the \emph{query}) in a given model structure. In case not the entire query exists, only the largest matching prefix of the query is located. The algorithm constructs a \emph{trace graph} which contains the nodes and edges which were traversed during search in the complete graph. The \emph{trace graph} is thus an augmented subgraph of the original graph which is rooted at the smallest vertex containing all of the matched string with paths to the location of both the beginning and end of the matched string.

\dfn{Trace Graph}{
    The trace graph $T_G^w$ of string $w \in \Sigma^*$ in context graph $G$ is a rooted subgraph found in $G$, representing $w$. The edges of $T$ at least one path starting from the first node, passing through the root node and ending in the last node representing substrings of the query.\par
    The edges can be divided into \emph{upward} and \emph{downward} edges, where upwards edges point to larger nodes and downwards edges point to smaller nodes.
    \begin{align*}
        \text{d}(a, b) =
        \begin{cases}
            \texttt{up}, &\text{ if } |a| < |b|\\
            \texttt{down}, &\text{ if } |a| > |b|\\
            \texttt{undefined}, &\text{ if } |a| = |b|\\
        \end{cases}
    \end{align*}

    to the last node (mirroring traversal order of the search algorithm).
    Edges are annotated with a distance $\text{dist}(e)$ to the first token, relative to the nodes they connect.
    \begin{align*}
        \text{dist}((a, b)) =
        \begin{cases}
            \text{prefix length before }w_0 \text{ in } a, &\text{ if } (a, b) \text{ is upwards edge,}\\
            \text{distance from }w_0 \text{ to beginning of } b, &\text{ if } (a, b) \text{ is downwards edge}\\
        \end{cases}
    \end{align*}
    The distance values are later used to determine the relative positions a node needs to be split at to construct new nodes from partial overlaps with other nodes.
}
\noindent To describe the search algorithm, let us assume there is an exising hypergraph structure that is correct according to our invariants. We can use our definition to make assumptions about the structure at every operation of the algorithm. A simple example of such a graph structure is given by the graph containing a single sequence without repetitions.

\noindent The search query is given as a string of vertex indices $q = (q_i)_{i \in \NN} \in I_V^*$, representing a string of either 1-gram tokens or larger n-gram substrings, meaning we are not limited to raw string search queries. The query is the pattern we are trying to find in the graph.

\noindent The search algorithm maintains a $queue$ of states with which it traverses all parse states in a breadth first manner. The states contain information about the locations in both the $query$ and the graph strucure $H$ to be compared. While traversing the graph, the algorithm populates a \textit{trace graph} with the locations of each end of the matched substring. These locations are later used to split any partially matching vertices for further processing.

%\begin{lstlisting}
%struct State {
%    key: int,
%    path: Path,
%    query_path: QueryPath,
%}
%\end{lstlisting}

%\begin{algorithm}
%    \caption{SEARCH}\label{alg:search}
%    \begin{flushleft}
%        \textbf{Input:} $[\texttt{VertexIndex}]\ query = q_0, \ldots q_n,\ \texttt{Grammar}\ G$\\
%        \textbf{Output:} $\texttt{TraceGraph}$
%    \end{flushleft}
%    \begin{algorithmic}
%        \State$trace \gets \texttt{TraceGraph}()$\Comment{Initialization}
%        \State$query\_path \gets \texttt{QueryPath}(query)$%
%
%        \State$queue \gets []$%
%        \State{$queue.\texttt{append}(\text{parent states for }q_0 \text{ with key }q_0.width)$}
%        \While{$queue$ has next $state$}
%            \State{$sk \gets state.key$}
%            \While{$state$ has successor $succ$}
%                \If{$query\_path$ has matching prefix in $succ$}
%                    \State{$sk \gets sk + s.width$}\Comment{found matching parent}
%                    \State{add path to $state.root$ to $trace$}
%                    \State{clear $queue$}
%                \ElsIf{$sk > k$}
%                    \State{add path from $state.root$ to last matching prefix to $trace$}
%                    \State$\texttt{return } trace$
%                \EndIf%
%            \EndWhile%
%            \State{append parent states of $p$ with key $sk$ to $queue$}
%        \State{$queue.\texttt{append}(\text{parent states for }p\text{ with key }sk)$}
%        \EndWhile%
%        \State$\texttt{return } trace$
%    \end{algorithmic}
%\end{algorithm}


%\begin{figure}
%\centering
%\begin{tikzpicture}[]
%    \graph [layered layout, nodes=draw, fresh nodes]{
%        {AB, AB, AB} -> AB -> {
%            AB -> {A, B},
%            BA -> {A, B}
%        };
%    };
%    \node [draw, fit= (AB) (AB') (AB'')] {};
%\end{tikzpicture}
%
%\caption{An example graph structure}
%\end{figure}

The algorithm can be understood as a parsing algorithm, matching the ''rules'' of graph structure on the query. This is a more intuitive description:
\begin{enumerate}
    \item Start at the first vertex index in the query $q_0$ and begin upwards traversal in $H$ in a breadth first manner using a queue
    \item Stop at each parent where there exists a successor to the child edge, i.e. the parent describes a context of $q_0$ with consequtive tokens
    \item Compare the successive vertex $s$ with the following token in the query $q_1$. there are three cases:
    \begin{itemize}
        \item $s$ and $q_1$ are equal: a matching transition has been found
        \item $s$ and $q_1$ are of same length but different: a mismatching transition has been found
        \item $s$ and $q_1$ are of different lengths: continue search by comparing the prefixes of the larger vertex $v_s$ with the smaller vertex $v_l$. If $v_s$ is a prefix of $v_l$, there must be a path from $v_l$ to $v_s$.  
    \end{itemize}
    If $v_l$ and $v_s$ exist, the matching algorithm continues to match the prefixes of $v_l$ with $v_s$.
    Once we encounter a prefix $p$ that is smaller than $v_s$, we can assume, based on the correct structure of $v_l$, that $v_s$ does not exist as a prefix of $v_s$. However it is still possible that $p$ and $v_s$ both share a prefix. Thus $v_s$ becomes the new $v_l$ and $p$ becomes the new $small$ and the algorithm repeats until $small$ and large are the same length, which is bound to happen as all vertices have a smallest prefix of length 1.
    The result of this matching is therefore always a path from the parent edge $s$ to a matching or mismatching prefix for both the query and the search cache.
\end{enumerate}

The resulting \texttt{TraceGraph} is used to store all the possible paths from the start vertex ($q_0$) to the root, aswell as from the root to the last vertex matching with the query. Each edge in the \texttt{TraceGraph} is an edge from the containment relation, annotated with a distance from the beginning of the query. These annotations are added during parsing and allow us to calculate the relative location of each border (start/end) inside of each vertex. This information is later used to split each vertex into parts which are then be recombined into new vertices.
